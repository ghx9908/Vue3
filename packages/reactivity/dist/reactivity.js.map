{
  "version": 3,
  "sources": [
    "../src/effect.ts",
    "../../shared/src/index.ts",
    "../src/handler.ts",
    "../src/reactivity.ts"
  ],
  "sourcesContent": [
    "export let activeEffect = undefined;// 当前正在执行的effect 为了方便执行effect的时候依赖收集\n\nexport class ReactiveEffect {\n  // 默认会将fn挂载到类的实例上\n  parent = undefined;\n  constructor(public fn) { }\n  run() {\n    try {\n      this.parent = activeEffect; // 当前的effect就是他的父亲\n      activeEffect = this; // 设置成正在激活的是当前effect\n      return this.fn();\n    } finally {\n      activeEffect = this.parent; // 执行完毕后还原activeEffect\n      this.parent = undefined;\n    }\n\n  }\n}\n\nexport function effect(fn) {\n  // 创建一个响应式effect,并且让effect执行\n  const _effect = new ReactiveEffect(fn);\n  _effect.run();\n}\n",
    "export const isObject = (value: unknown): value is Record<any, any> => {\n  // return Object.prototype.toString.call(value) === '[object Object]';\n  return value !== null && typeof value === 'object'\n} \n",
    "import { activeEffect } from \"./effect\";\nimport { ReactiveFlags } from \"./reactivity\";\n\nexport const muableHandlers: ProxyHandler<object> = {\n  // receiver相当于代理对象\n  get(target, key, receiver) {\n    //取值的时候，让属性和effect产生关系\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true;\n    }\n\n    return Reflect.get(target, key, receiver)\n  },\n  set(target, key, value, receiver) {\n    //设置的时候，让属性对应的effect执行\n    Reflect.set(target, key, value, receiver)\n    return true\n  },\n}\n",
    "import { isObject } from \"@vue/shared\";\nimport { muableHandlers } from \"./handler\";\n\nexport const enum ReactiveFlags { // 对象\n  IS_REACTIVE = \"__v_isReactive\",\n}\nconst reactiveMap = new WeakMap()\nexport function reactive(target: object) {\n  // reactive 只能处理对象类型的数据，不是对象不处理\n  if (!isObject(target)) return target\n\n  // 缓存可以采用映射表 {{target} -> proxy}\n  let existingProxy = reactiveMap.get(target)// 看一下这个对象是否有被代理过\n  if (existingProxy) return existingProxy// 代理过直接返回\n\n  //防止对象重复被代理\n  if (target[ReactiveFlags.IS_REACTIVE]) {\n    return target;\n  }\n\n  const proxy = new Proxy(target, muableHandlers)// 没有代理过创建代理\n  reactiveMap.set(target, proxy) // 缓存代理结果\n\n  // 1） 在vue3.0的时候 会创造一个反向映射表 {代理的结果 -》 原内容}\n  // 2) 目前不用创建反向映射表，用的方式是，如果这个对象被代理过了说明已经被proxy拦截过了\n  return proxy\n}\n"
  ],
  "mappings": ";AAAO,IAAI,eAAe;AAEnB,IAAM,iBAAN,MAAqB;AAAA,EAG1B,YAAmB,IAAI;AAAJ;AADnB,kBAAS;AAAA,EACgB;AAAA,EACzB,MAAM;AACJ,QAAI;AACF,WAAK,SAAS;AACd,qBAAe;AACf,aAAO,KAAK,GAAG;AAAA,IACjB,UAAE;AACA,qBAAe,KAAK;AACpB,WAAK,SAAS;AAAA,IAChB;AAAA,EAEF;AACF;AAEO,SAAS,OAAO,IAAI;AAEzB,QAAM,UAAU,IAAI,eAAe,EAAE;AACrC,UAAQ,IAAI;AACd;;;ACvBO,IAAM,WAAW,CAAC,UAA8C;AAErE,SAAO,UAAU,QAAQ,OAAO,UAAU;AAC5C;;;ACAO,IAAM,iBAAuC;AAAA,EAElD,IAAI,QAAQ,KAAK,UAAU;AAEzB,QAAI,4CAAmC;AACrC,aAAO;AAAA,IACT;AAEA,WAAO,QAAQ,IAAI,QAAQ,KAAK,QAAQ;AAAA,EAC1C;AAAA,EACA,IAAI,QAAQ,KAAK,OAAO,UAAU;AAEhC,YAAQ,IAAI,QAAQ,KAAK,OAAO,QAAQ;AACxC,WAAO;AAAA,EACT;AACF;;;ACfO,IAAW,gBAAX,kBAAWA,mBAAX;AACL,EAAAA,eAAA,iBAAc;AADE,SAAAA;AAAA,GAAA;AAGlB,IAAM,cAAc,oBAAI,QAAQ;AACzB,SAAS,SAAS,QAAgB;AAEvC,MAAI,CAAC,SAAS,MAAM;AAAG,WAAO;AAG9B,MAAI,gBAAgB,YAAY,IAAI,MAAM;AAC1C,MAAI;AAAe,WAAO;AAG1B,MAAI,OAAO,qCAA4B;AACrC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,IAAI,MAAM,QAAQ,cAAc;AAC9C,cAAY,IAAI,QAAQ,KAAK;AAI7B,SAAO;AACT;",
  "names": [
    "ReactiveFlags"
  ]
}
